


#-----------------------------------------------------------------------------------------------------
#Декараторы
#-----------------------------------------------------------------------------------------------------
#import webbrowser #библеотека которая позваляет работать с веб браузерами
#import time
#
#
##сам декоратор
##декоратор добавляет функционал к той или иной функции, может срабатывать либо до функции либо после, можно делать несколько декораторов в одной функции
#def decaration(func):       #декоратор, обычно называют как хотят, и принемают значение функции(по сути любое)
#    def obertka(web):       #объёртка нашего декоратора которая открывает веб сайт от нашей функции
#        print("До функции")
#        time.sleep(10)      #ждём
#        func(web)           #открываем веб сайт
#        print("После функции")
#    return obertka          #Возвращаем значение объёртки от веб сайта
#
#@decaration   #привязываем декоратор
#def open_web(web):      #функция для открытия веб сайта
#    webbrowser.open(web) #открываем веб сайт по заданному адресу
#
#open_web("https://www.youtube.com")


#----------------------------------------------------------------------------------------------------------
#Наследование , инкапсуляция , полиморфизм
#----------------------------------------------------------------------------------------------------------
#наследование помагает создать один клас на основе которого можно будет создавать подклассы, при этом начальный класс называется родителем илиже супер классом

#инкапсуляция это защита классов или же оболочки, в pyton она реализована тут не очень хорошо и чтобы её сделать просто перед значением необходимо поставить __
#при желании можно её не делать она просто есть) и обычно используется

#class persona():        #Основной класс который является родителем подкласов расс
#    race = None
#    name = None
#    HP = None
#    SP = None
#    isrange = None
#    Attak = None
#    Ability = None
#
#    def __init__(self,race = None,name = None,HP = None,SP = None,isrange = None,Attak = None,Ability = None):
#        self.set_info(race,name,HP,SP,isrange,Attak,Ability)
#        self.get_info()
#    def set_info(self,race = None,name = None,HP = None,SP = None,isrange = None,Attak = None,Ability = None):
#        self.race = race
#        self.name = name
#        self.HP = HP
#        self.SP = SP
#        self.isrange = isrange
#        self.Attak = Attak
#        self.Ability = Ability
#    def get_info(self):
#        print("Раса:                ",self.race," \nИмя:                 ", self.name, " \nЗдоровье:            ", self.HP, " \nМана:                ", self.SP," \nРадиус атаки:        ",self.isrange," \nУрон:                ",self.Attak," \nСпособности:         ",self.Ability, sep=" ", end="\n")
#    def saw(self):
#        print("Говорит ", end= " ") # начальныя функция saw
#
#
##полиморфизм дайт возможность изметь функции в подклассе на основе родительской функции
#
#class goblin(persona):      #подкласс от класса person наследует все его функции и вещи, но нужно вызывать это самостоятельно
#    def __init__(self,race = None,name = None,HP = None,SP = None,isrange = None,Attak = None,Ability = None):      #вызываем запуск при начале работы и выбираем нужные нам значение
#        super(goblin, self).__init__(race,name,HP,SP,isrange,Attak,Ability)
#
#    def get_info(self):
#        super().get_info()
#        print("Особенность Расы:     Цыган\n")
#
#    def saw(self):      #переделанная функция saw на основе родительской функции, для перепесания нужной функции необходимо просто обротится к ней и добавть что хочешь
#        super().saw()
#        print("Я Гоблин")
#
#
#
#class elf(persona):
#    def __init__(self,race = None,name = None,HP = None,SP = None,isrange = None,Attak = None,Ability = None):
#        super(elf, self).__init__(race, name, HP, SP, isrange, Attak, Ability)
#
#    def get_info(self):
#        super().get_info()
#        print("Особенность Расы:     Связь с Природой\n")
#
#    def saw(self):      #переделанная функция saw на основе родительской функции, для перепесания нужной функции необходимо просто обротится к ней и добавть что хочешь
#        super().saw()
#        print("Я Эльф")
#
#
#class dworf(persona):
#    def __init__(self, race=None, name=None, HP=None, SP=None, isrange=None, Attak=None, Ability=None):
#        super(dworf, self).__init__(race, name, HP, SP, isrange, Attak, Ability)
#
#    def get_info(self):
#        super().get_info()
#        print("Особенность Расы:     Рудокоп\n")
#
#    def saw(self):      #переделанная функция saw на основе родительской функции, для перепесания нужной функции необходимо просто обротится к ней и добавть что хочешь
#        super().saw()
#        print("Я Дворф")
#print("Введите Расу вашего персонажа, его имя,здоровье,ману,радиус атаки, урон,Способности, если что-то отсутствует поставте пробел")
#persona_Tany = persona(input(),input(),input(),input(),input(),input(),input())

#тут сам вызов наших классов и под классов, для подклассов доступны все функции класса(родителя)

#persana_one = persona(input(),input(),input(),input(),input(),input(),input())
#persana_two = goblin("Гоблин", "Инокентий")
#persana_thee = elf("Эльф", "Вышибатя")
#persana_four = dworf("Дворф","Пивовар")
#persana_two.saw()


#----------------------------------------------------------------------------------------------------------
#Конструкторы и переопределение
#----------------------------------------------------------------------------------------------------------


#class cat:
#    name = None
#    age = None
#    Happy = None
#    cvet = None
#
#    def __init__(self,n = None,a = None,h = None,c = None): #для создание конструктора требуется слова с двумя подчёркиваниями с каждых сторон со словом init, он при зазданиие объекта сразу производит операцию
#        self.set_data(n,a,h,c) # благодаря переопределению можно писать не сразу все нужные параметры а передавть по одному,для этого нужно указать изначальное значение переменной
#        self.get_data()
#    def set_data(self, n = None,a = None,h = None,c = None):
#        self.name = n
#        self.age = a
#        self.Happy = h
#        self.cvet = c
#    def get_data(self):
#        print("Ваш Кот : ",self.name," Ему ", self.age," Он ", self.Happy," Цвет Шерсти ", self.cvet, sep= " ")
#
#cat1 = cat("Valera", "6  лет", "Довольный", "рыжий")
#cat2 = cat("Царь", "12  лет")


#--------------------------------------------------------------------------------------------------------
## Осноавы ООП создание класса и объекта
## Объектно-Оринтированное Програмирование
#--------------------------------------------------------------------------------------------------------

#для создание класа нужно прописывать class : и вводить нужные данные для того чтобы зосдать уже на основе класа вещь нужно в водить так вещь = название класса() и круглые скобки

#class cat:
#    name = None
#    age = None
#    Happy = None
#    cvet = None
#
#    def set_data(self, n,a,h,c): #self всегда должен быть внутри класса, также в нутри класса функция называется методам функция ==== методом
#        self.name = n
#        self.age = a
#        self.Happy = h
#        self.cvet = c
#    def get_data(self):
#        print("Ваш Кот : ",cat1.name," Ему ", cat1.age," Он ", cat1.Happy," Цвет Шерсти ", cat1.cvet, sep= " ")


#cat1 = cat()
#cat1.set_data(input("Введите название Кота, его Возраст, Счастье и Цвет Шерсти\n"), input(), input(), input())
#cat1.get_data()






#-------------------------------------------------------------------------------------------------------
##модули / библеотеки
#-------------------------------------------------------------------------------------------------------
#нужные библеотеки ищи в инете
#Вот основные
#для подключение изпользуется слово import, для подключение конкретного действия from библеотека import нужное действие, также можно давать пвсевдониму спомощью as


#math #библеотека матемаатики
#platform #библеотека для работы с платформой
#os # по идеи тоже что и platform
#sys #для работы с системой
#datatime / time #работа с датой и временем / только с временем
#random # позваляет работать с рандомными числами

#from math inport sqrt as s

# при желании можно импортировать свои модули и создавать их также при помощи import
# для получение значений нужно : название модуля . переменную или что-то другое

#import Zadaci as z
#z.valera()

#для устоновки различных пользовательских библеотек используется PyPi
# её нужно прописывать в терменале по типу pip install cowsay

#import cowsay as c
#c.cow("Help")


#--------------------------------------------------------------------------------------------------
##Менеджер файлов
#-------------------------------------------------------------------------------------------------

##try:
##    with open("data/test.txt", "r") as file:
##        print(file.read())
##except FileNotFoundError:
##    print("фаил не найден")


## после with мы открываем фаил и после работы он автоматически закрывается
## в скобаках пишем места располажение файла и какой фаил открыть,режим чтение или запись
## в режиме чтения не возможно создать фаил, только прочитать, а в режиме записи можно создать фаил








#-------------------------------------------------------------------------------------------------
##Исключение
#-------------------------------------------------------------------------------------------------
##x = 0
##y = 0
##while((x == 0) and (y == 0)):
##    try:        #выполняет если не было ошибок
##        x = int(input("Введите первое значение : "))
##        y = int(input("Введите второе значение : "))
##        print(x / y)
##    except ValueError:    #если случилась ошибка то выполняется код с ошибкой, такможно отслеживать любую ошибку
##        print("Введите число, а не слово")
##    except ZeroDivisionError:
##        print("Деление на ноль")
##    finally:            #срабатывает в любом случаи когда ко доходит до конца
##        print("Давай по новой")







#-----------------------------------------------------------------------------------------------
##Работа с файлами
#-----------------------------------------------------------------------------------------------

##file = open("data/test.txt","a") #сначала идёт открытие файла, затем путь и название что открываем и после вид
##"r" открытие на чтение(значение по умолчанию)
##"w" открытие на запись, если файла нет то создаёт и добавляет, при каждом запуске стирает прошлые слова
##"x" открытие на запись, если файла нет,иначе исключение
##"a" открывает на до запись, добавляет информацию в конец файла(строки)
##"b" открывает в двоичном формате
##"t" открывает в текстовом режиме(значение по умолчанию)
##"+" открывает на чтение и запись
##value = str(input())
##file.write(value + "\n") #запись в фаил
##
##file.close() #после работы с файлом необходимо его зарыть
##
##file = open("data/test.txt", "r") #открываем для чтения
###print(file.read(10)) # выводит по одному символу в () можно указывать сколько символов хотите считать
##for line in file:     # выводит по строчно то что написанно в файле
##    print(line, end= " ")
##
##
##file.close()


#----------------------------------------------------------------------------------------------
##Функции
#----------------------------------------------------------------------------------------------


##def firs_funcshion(mun1,num2,dev): #для создание функции нужно использовать def_название функции(при желании значение которое будет принимать)
##    itog = 0
##    if(dev == "+"):
##        itog = num1 + num2
##    elif(dev == "-"):
##        itog = num1 - num2
##    elif(dev == "*"):
##        itog = num1 * num2
##    elif(dev == "/"):
##        itog = num1 / num2
##    elif(dev == "**"):
##        itog = num1 ** num2
##    elif(dev == "//"):
##        itog = num1 // num2
##    return itog #return используется для того чтобы забрать значение из функции
##
##num1 = float(input("\nВведите первое число : "))
##num2 = float(input("Введите второе число : "))
##dev = input("Введите Действие : ")
##itog = firs_funcshion(num1,num2,dev)
##print("Вы получили : ", itog)


##summa = lambda x,y : x + y # lambda анонимная функция которая выполняет небольшие стройки кода, требует запись в переменную в нашем случаи summa
##(print(summa(14,2))) # для выполнения нужно вызывать как функцию


#----------------------------------------------------------------------------------------------
##множество
#---------------------------------------------------------------------------------------------

##value = set("Slava") #Создаёт множество которое удаляет повтаряющие символы, но перемешивает их местами на рандом
##value = {5,2,4,23,4,2,5,0} #если не указывать ключ то будет созанно множество, а не словарь, выводит по возрастанию
##value.add(352) #добавляет ко множеству значение
##value.update(["gdf",342,True]) #добавляет несколько чисел
##value.remove(342) #удаление нужного значения
##value.pop() #удаляет первый элимент
##value.clear() # очищает множество
##frozenset([2414,324,"3sfds, True]) #оздаёт картеж и убирает повторяющиеся символы, после добавлять изменять нельзя
##print(value)


#-----------------------------------------------------------------------------------------
##Словарь
#-----------------------------------------------------------------------------------------

##person = {
##    "user_1" : {
##        "Фамилия" : "Иосиф",
##        "Имя" : "Сталин",
##        "возраст" : 45,
##        "адрес" : ("г. Москва", "ул. Советская", "24"),
##        "оценка" : {"Командование": 5, "Управление": 5}
##    },
##    "user_2" : {
##        "Фамилия": "Лев",
##        "Имя": "Троцкий",
##        "возраст": 36,
##        "адресс": ("г. Македония", "ул. Цыган", "24"),
##        "оценка": {"Командование": 3, "Управление": 2}
##    }
##}
##print(person["user_1"]["адрес"][1])
##for key, value in person.items():
##    print(key, " - ", value)


##count = {1: 3,2: "Валера", (5,6): 14} #словари которым нужно добавить ключ(название), ключ может иметь вид картежа
##print(count[5,6])
Count = {"код": "Русские","Национальность": "Многанациональная","Популяция":"120 милионнов","партия":"Демократия"}
##print(Count)
##print(Count.get("код")) #альт получение значений == []
##Count.clear() #очистка словаря
##Count.pop("Популяция") #удаление определённого значения и ключа
##Count.popitem() #удаление последнего ключа и значений
##print(Count.keys()) #получение ключей
##print(Count.values()) #получение значений
##Count["код"] = "отсутствует" #изменяет значение в словаре или через функцию .update
##for key, znax in Count.items(): #перебираем сначала ключ потом значение ключа .item выдаёт всё значение списка который состаит из картеджей
##   print(key, " - ", znax)
##Count = dict(code= "Ru", name= "Russia") #Альт создание словарей

#-----------------------------------------------------------------------------------------
##Кортежи
#-----------------------------------------------------------------------------------------

##vela = (15,123,"Stalingrad",False,"Ni") #кортежи занимают меньше памяти и работают также как обычный массив
##vela[0] = 5 нельзя добавлять или изменять значение в картежах
##работает с картежами .count и len()
##для создания картежа необходима создать миниммум хоть что и после него поставить запитую, у картежа () скобки
##
##nums = [124, 11, 42]
##new_nums = tuple(nums) #преобразование обычного масива в картеж
##
##words = "Stalingrad"
##new_words = tuple(words) #преобразование строки в картеж
##print(new_words[0:])

##word = "Слава СССР"
##print(word[0:10:1]) #Срез идёт от отного индекса до другого, а также можно выбрать шаг при отрицательном значении шага то список переворачивается
##listok = [1, 5.1, "Sovet", True, -2]
##print(listok[1:])

#-----------------------------------------------------------------------------------------
##работа со строками
#-----------------------------------------------------------------------------------------

##word = "Валера, выпивает, чай"
#print(word.upper()) #делает все буквы заглавные
#print(word.lower()) #делает все буквы млатшими
#print(word.capitalize()) #делаает первую букву заглавной
#print(word.find("в")) #ищёт нужную букву и выводит её Индекс
#what = word.split(", ") #разбивает строку по нужному(нужным) символу создавая массив
#
#for i in range(len(what)): #цикл от длины массива где каждая последуйщая часть слова становится заглавной
#    what[i] = what[i].capitalize()
#
#resout = ", ".join(what) #объединяем масив в строку по нужному знаку
#print(resout)

#-----------------------------------------------------------------------------------------
##массив
#-----------------------------------------------------------------------------------------

#numbers = [0,1,2] #массив не имеет привязки к типу данных как и другие переменные
#numbers.append(1000) #добавляем новый индекс в конец и записсываем в него число
#numbers.insert(1, True) #запись значение в нужный индекс те идекса которые были после него смещаются на 1 в право
#b = [23,13,False]
#numbers.extend(b)#расширяем один массив за счёт другого числа или масива
#numbers.sort() #Сортировка массива от наименьшего к наибольшемму не может сортировать строки
#numbers.reverse() #переворачивает значение местами те 0 индекс стаёт последним
#numbers.pop() #удаляет последний элимент массива если не вводить индекс
#numbers.remove(1) #удаляет нужную цифру
##numbers.clear() #Очищает массив
#print(numbers)
#print(numbers.count(True)) #Показывает сколько совпадений в массиве
#print(len(numbers)) #показывает размер массива

#-----------------------------------------------------------------------------------------
##мини массивы
#-----------------------------------------------------------------------------------------

##numbers = [0,1,2,3,4,5,6,7,8 ,[9,10]]
##
##numbers[0] = int(input())
##numbers[1] = float(input())
##numbers[-1][1] = float(input())
##
##print(numbers[-1][1], sep= " ")

#-----------------------------------------------------------------------------------------
##разбирался
#-----------------------------------------------------------------------------------------

#for i in range (10):
#    print(i)
#
#i = 0
#while(1):
#    i += 1
#    if(i == 100):
#        break
#    print(i, end= " ")
#
#num1 = float(input("\nВведите первое число : "))
#num2 = float(input("Введите второе число : "))
#dev = input("Введите Действие : ")
#itog = 0
#
#if(dev == "+"):   #В pyton отсутствует switch
#    itog = num1 + num2
#elif(dev == "-"):
#    itog = num1 - num2
#elif(dev == "*"):
#    itog = num1 * num2
#elif(dev == "/"):
#    itog = num1 / num2
#elif(dev == "**"):
#    itog = num1 ** num2
#elif(dev == "//"):
#    itog = num1 // num2
#
#print("Вы получили : ", itog)


#-----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------

n = int(input())
num = ''
i = 0
while len(num) < n:
    if(i == len(str(n))):
        break
    num += str(i)
    i += 1
print(num)